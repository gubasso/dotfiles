#!/usr/bin/env bash
#
# gnome-shortcuts-audit - Audit GNOME keybindings for duplicate accelerators
#
# Scans GSettings for keyboard shortcuts across:
#   - Mutter/WM keybindings (org.gnome.desktop.wm.keybindings)
#   - GNOME Shell keybindings (org.gnome.shell.keybindings)
#   - Mutter keybindings (org.gnome.mutter.keybindings, wayland variant)
#   - Media keys + custom shortcuts (org.gnome.settings-daemon.plugins.media-keys)
#   - Extensions (org.gnome.shell.extensions.*)
#   - Any schema matching: keybindings, shortcut, hotkey
#
# This tool is READ-ONLY: it does not modify any settings.
#
# USAGE:
#   gnome-shortcuts-audit [OPTIONS]
#
# OPTIONS:
#   -a, --all                   Show all accelerators (default)
#   -d, --duplicates            Show only duplicates; exit 1 if any found
#   -s, --schema REGEX          Filter owners by schema (case-insensitive regex)
#   -k, --accel REGEX           Filter accelerators (case-insensitive regex; matches original or normalized)
#   -o, --owner REGEX           Filter owner line (schema/key/detail; case-insensitive)
#   -r, --raw                   Raw TSV output: accel<TAB>schema_instance<TAB>key<TAB>detail
#   -j, --json                  JSON output
#       --no-color              Disable ANSI colors (human output)
#   -q, --quiet                 Suppress progress messages
#       --list-schemas          List discovered candidate schemas and exit
#       --list-relocatable      List relocatable schemas and exit
#       --list-keys SCHEMA[:PATH]
#                               List keys for a schema instance and exit
#   -h, --help                  Show this help
#
# EXAMPLES:
#   gnome-shortcuts-audit
#   gnome-shortcuts-audit -d
#   gnome-shortcuts-audit -s paperwm
#   gnome-shortcuts-audit -k '<Super>'
#   gnome-shortcuts-audit -o 'media-keys\.custom'
#   gnome-shortcuts-audit -r
#   gnome-shortcuts-audit -j
#   gnome-shortcuts-audit --list-schemas
#   gnome-shortcuts-audit --list-keys org.gnome.desktop.wm.keybindings
#
# EXIT CODES:
#   0 - Success (or no duplicates in -d mode)
#   1 - Duplicates found (only in -d mode)
#   2 - Error / invalid usage
#
# END_HELP

set -euo pipefail
export LC_ALL=C

# ------------------------------------------------------------------------------
# Usage: extracted from header docstring (single source of truth).
# ------------------------------------------------------------------------------
usage() {
  # Print everything from "# USAGE:" up to (but not including) "# END_HELP"
  sed -n '/^# USAGE:$/,/^# END_HELP$/{
    /^# END_HELP$/q
    s/^# \?//
    p
  }' "$0"
  exit 0
}

# ----------------------------
# Defaults / CLI state
# ----------------------------
MODE="all"              # all|duplicates
FORMAT="human"          # human|raw|json
FILTER_SCHEMA=""        # regex, case-insensitive
FILTER_ACCEL=""         # regex, case-insensitive
FILTER_OWNER=""         # regex, case-insensitive (matches "schema key [detail]")
NO_COLOR=false
QUIET=false
TMP=""
LIST_SCHEMAS=false
LIST_RELOCATABLE=false
LIST_KEYS_SCHEMA=""

# ----------------------------
# Core schema set (high-value)
# ----------------------------
CORE_SCHEMAS=(
  "org.gnome.desktop.wm.keybindings"
  "org.gnome.shell.keybindings"
  "org.gnome.mutter.keybindings"
  "org.gnome.mutter.wayland.keybindings"
  "org.gnome.settings-daemon.plugins.media-keys"
)

DISCOVERY_REGEX='(keybindings|keybinding|shortcut|shortcuts|hotkey|hotkeys)'
EXT_PREFIX="org.gnome.shell.extensions."

# ----------------------------
# Helpers
# ----------------------------
die() { printf "error: %s\n" "$*" >&2; exit 2; }

log() {
  [[ "$QUIET" == true ]] && return 0
  printf "%s\n" "$*" >&2
}

have() { command -v "$1" >/dev/null 2>&1; }

is_tty() { [[ -t 1 ]]; }

use_color() { is_tty && [[ "$NO_COLOR" == false ]]; }

trim() {
  # Pure bash whitespace trim
  local s="$1"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf "%s" "$s"
}

# ----------------------------
# GNOME accelerator heuristics
# ----------------------------
looks_like_accel() {
  local s
  s="$(trim "$1")"
  [[ -z "$s" ]] && return 1
  [[ "$s" == "disabled" || "$s" == "none" || "$s" == "nothing" ]] && return 1
  [[ "$s" == @* || "$s" == /* || "$s" == *" "* ]] && return 1

  # GNOME standard: <Modifier>key
  [[ "$s" == \<*\>* ]] && return 0

  # XF86 media keys
  [[ "$s" =~ ^XF86[[:alnum:]_]+$ ]] && return 0

  # Function keys
  [[ "$s" =~ ^F([1-9]|1[0-9]|2[0-4])$ ]] && return 0

  # Named keys
  case "$s" in
    Print|Pause|Menu|Tab|Escape|Home|End|Page_Up|Page_Down|Insert|Delete|BackSpace|Return|Enter|space|Up|Down|Left|Right)
      return 0 ;;
  esac

  # Single alphanumeric (rare)
  [[ "$s" =~ ^[[:alnum:]]$ ]] && return 0

  # Keysyms with underscore (KP_1, Page_Up, etc.)
  [[ "$s" =~ ^[[:alnum:]_]+$ && "$s" == *_* ]] && return 0

  return 1
}

normalize_accel() {
  # Canonicalize modifier aliases and ordering.
  # For non-<...> accelerators (XF86...), return as-is.
  local a
  a="$(trim "$1")"
  [[ "$a" != *"<"* ]] && { printf "%s" "$a"; return 0; }

  local rest="$a"
  local -a mods=()
  local m

  while [[ "$rest" =~ ^\<([^>]*)\>(.*)$ ]]; do
    m="${BASH_REMATCH[1]}"
    rest="${BASH_REMATCH[2]}"

    case "${m,,}" in
      primary|control|ctrl) m="Ctrl" ;;
      mod1|alt)             m="Alt" ;;
      shift)                m="Shift" ;;
      super|mod4)           m="Super" ;;
      meta)                 m="Meta" ;;
      hyper)                m="Hyper" ;;
      *)                    m="$m" ;;
    esac
    mods+=("$m")
  done

  # Deduplicate
  local -A seen=()
  for m in "${mods[@]}"; do
    seen["$m"]=1
  done

  # Canonical order
  local -a ordered=()
  for m in Ctrl Alt Shift Super Meta Hyper; do
    [[ -n "${seen[$m]:-}" ]] && ordered+=("$m") && unset "seen[$m]"
  done

  # Append remaining (unknown modifiers, sorted)
  local -a unknown=()
  for m in "${!seen[@]}"; do
    unknown+=("$m")
  done
  if ((${#unknown[@]} > 0)); then
    mapfile -t unknown < <(printf "%s\n" "${unknown[@]}" | sort)
    ordered+=("${unknown[@]}")
  fi

  local out=""
  for m in "${ordered[@]}"; do
    out+="<${m}>"
  done
  out+="$rest"

  printf "%s" "$out"
}

extract_quoted_strings() {
  # Extract all single-quoted tokens from a GVariant string.
  local v="$1"
  printf "%s" "$v" | grep -oE "'[^']*'" | sed "s/^'//; s/'$//" || true
}

# ----------------------------
# Schema discovery
# ----------------------------
list_all_schemas() {
  {
    gsettings list-schemas 2>/dev/null || true
    gsettings list-relocatable-schemas 2>/dev/null || true
  } | sort -u
}

discover_candidate_schemas() {
  local all
  all="$(list_all_schemas)"
  local -a out=()
  local s

  for s in "${CORE_SCHEMAS[@]}"; do
    grep -Fxq "$s" <<<"$all" && out+=("$s")
  done

  while IFS= read -r s; do
    [[ -n "$s" ]] && out+=("$s")
  done < <(grep -E "^${EXT_PREFIX}" <<<"$all" || true)

  while IFS= read -r s; do
    [[ -n "$s" ]] && out+=("$s")
  done < <(grep -Ei "$DISCOVERY_REGEX" <<<"$all" || true)

  printf "%s\n" "${out[@]}" | sort -u
}

derive_schema_instances() {
  # Emit schema instances:
  # - Non-relocatable: SCHEMA
  # - Relocatable: we attempt a best-effort extension-path heuristic
  local schema="$1"

  if gsettings list-schemas 2>/dev/null | grep -Fxq "$schema"; then
    printf "%s\n" "$schema"
    return 0
  fi

  gsettings list-relocatable-schemas 2>/dev/null | grep -Fxq "$schema" || return 0

  # Extension heuristic: org.gnome.shell.extensions.NAME -> /org/gnome/shell/extensions/name/
  if [[ "$schema" == "${EXT_PREFIX}"* ]]; then
    local name="${schema#"${EXT_PREFIX}"}"
    printf "%s:/org/gnome/shell/extensions/%s/\n" "$schema" "$name"
  fi
}

schema_has_keys() {
  gsettings list-keys "$1" >/dev/null 2>&1
}

# ----------------------------
# Collector
# Each collector prints TSV records to stdout:
#   norm <TAB> orig <TAB> schema_instance <TAB> key <TAB> detail
# ----------------------------
collect_from_schema_instance() {
  local inst="$1"
  schema_has_keys "$inst" || return 0

  local schema key value_rest accel norm
  while IFS=$' \t' read -r schema key value_rest; do
    [[ -z "${schema:-}" || -z "${key:-}" || -z "${value_rest:-}" ]] && continue
    [[ "$value_rest" != *"'"* ]] && continue

    while IFS= read -r accel; do
      [[ -z "$accel" ]] && continue
      looks_like_accel "$accel" || continue
      norm="$(normalize_accel "$accel")"
      printf "%s\t%s\t%s\t%s\t%s\n" "$norm" "$accel" "$inst" "$key" ""
    done < <(extract_quoted_strings "$value_rest")

  done < <(gsettings list-recursively "$inst" 2>/dev/null)
}

collect_custom_media_keys() {
  local base="org.gnome.settings-daemon.plugins.media-keys"
  schema_has_keys "$base" || return 0

  local paths_value
  paths_value="$(gsettings get "$base" custom-keybindings 2>/dev/null || echo "@as []")"
  [[ "$paths_value" == "@as []" || "$paths_value" == "[]" ]] && return 0

  local path inst name binding command accel norm detail
  while IFS= read -r path; do
    [[ -z "$path" ]] && continue

    inst="org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:${path}"
    schema_has_keys "$inst" || continue

    name="$(gsettings get "$inst" name 2>/dev/null || echo "''")"
    binding="$(gsettings get "$inst" binding 2>/dev/null || echo "''")"
    command="$(gsettings get "$inst" command 2>/dev/null || echo "''")"

    name="${name#\'}"; name="${name%\'}"
    command="${command#\'}"; command="${command%\'}"

    while IFS= read -r accel; do
      [[ -z "$accel" ]] && continue
      looks_like_accel "$accel" || continue
      norm="$(normalize_accel "$accel")"
      detail="name=${name}; command=${command}"
      printf "%s\t%s\t%s\t%s\t%s\n" "$norm" "$accel" "$inst" "binding" "$detail"
    done < <(extract_quoted_strings "$binding")

  done < <(printf "%s" "$paths_value" | grep -oE "'/[^']+/'" | tr -d "'" || true)
}

# ----------------------------
# Reporting
# ----------------------------
report_human() {
  local duplicates_only="$1"
  local uc=0
  use_color && uc=1

  awk -v dup_only="$duplicates_only" \
      -v schema_re="$FILTER_SCHEMA" \
      -v accel_re="$FILTER_ACCEL" \
      -v owner_re="$FILTER_OWNER" \
      -v use_color="$uc" \
      -v mode="$MODE" \
'
function ci_match(s, re) { return re == "" || tolower(s) ~ tolower(re) }
function esc(s) { gsub(/\t/, "    ", s); return s }
BEGIN { FS=OFS="\t" }
{
  norm=$1; orig=$2; schema=$3; key=$4; detail=$5
  if (!ci_match(schema, schema_re)) next
  if (!ci_match(orig, accel_re) && !ci_match(norm, accel_re)) next

  owner_line = schema " " key
  if (detail != "") owner_line = owner_line " [" detail "]"
  if (!ci_match(owner_line, owner_re)) next

  id = norm SUBSEP schema SUBSEP key SUBSEP detail
  if (id in seen) next
  seen[id] = 1
  owners[norm] = owners[norm] "\n" owner_line
  owner_count[norm]++
  if (!(norm in first_orig)) first_orig[norm] = orig
}
END {
  n = 0
  for (k in owner_count) norms[n++] = k
  for (i = 0; i < n; i++)
    for (j = i + 1; j < n; j++)
      if (norms[j] < norms[i]) { t = norms[i]; norms[i] = norms[j]; norms[j] = t }

  dup_found = 0
  for (i = 0; i < n; i++) {
    k = norms[i]; c = owner_count[k]
    if (dup_only == "true" && c <= 1) continue
    if (c > 1) dup_found = 1

    a = first_orig[k]
    if (use_color) {
      if (c > 1) printf "\033[1;31m%s\033[0m \033[1;33m[DUPLICATE: %d owners]\033[0m\n", a, c
      else        printf "\033[1;32m%s\033[0m\n", a
    } else {
      if (c > 1) printf "%s [DUPLICATE: %d owners]\n", a, c
      else       printf "%s\n", a
    }

    nlines = split(owners[k], lines, "\n")
    for (li = 1; li <= nlines; li++)
      if (lines[li] != "") printf "  - %s\n", esc(lines[li])
    print ""
  }

  exit (mode == "duplicates" && dup_found ? 1 : 0)
}
'
}

report_raw() {
  local duplicates_only="$1"

  awk -v dup_only="$duplicates_only" \
      -v schema_re="$FILTER_SCHEMA" \
      -v accel_re="$FILTER_ACCEL" \
      -v owner_re="$FILTER_OWNER" \
'
function ci_match(s, re) { return re == "" || tolower(s) ~ tolower(re) }
BEGIN { FS=OFS="\t" }
{
  norm=$1; orig=$2; schema=$3; key=$4; detail=$5
  if (!ci_match(schema, schema_re)) next
  if (!ci_match(orig, accel_re) && !ci_match(norm, accel_re)) next

  owner_line = schema " " key
  if (detail != "") owner_line = owner_line " [" detail "]"
  if (!ci_match(owner_line, owner_re)) next

  id = norm SUBSEP schema SUBSEP key SUBSEP detail
  if (id in seen) next
  seen[id] = 1
  rec[++nrec] = $0
  cnt[norm]++
}
END {
  for (i = 1; i <= nrec; i++) {
    split(rec[i], f, "\t")
    if (dup_only == "true" && cnt[f[1]] <= 1) continue
    print f[2], f[3], f[4], f[5]
  }
}
'
}

report_json() {
  local duplicates_only="$1"

  awk -v dup_only="$duplicates_only" \
      -v schema_re="$FILTER_SCHEMA" \
      -v accel_re="$FILTER_ACCEL" \
      -v owner_re="$FILTER_OWNER" \
'
function ci_match(s, re) { return re == "" || tolower(s) ~ tolower(re) }
function jesc(s) { gsub(/\\/,"\\\\",s); gsub(/"/,"\\\"",s); gsub(/\t/,"\\t",s); gsub(/\r/,"\\r",s); gsub(/\n/,"\\n",s); return s }
BEGIN { FS=OFS="\t"; print "{" }
{
  norm=$1; orig=$2; schema=$3; key=$4; detail=$5
  if (!ci_match(schema, schema_re)) next
  if (!ci_match(orig, accel_re) && !ci_match(norm, accel_re)) next

  owner_line = schema " " key
  if (detail != "") owner_line = owner_line " [" detail "]"
  if (!ci_match(owner_line, owner_re)) next

  id = norm SUBSEP schema SUBSEP key SUBSEP detail
  if (id in seen) next
  seen[id] = 1
  owners[norm] = owners[norm] "\n" owner_line
  owner_count[norm]++
  if (!(norm in first_orig)) first_orig[norm] = orig
}
END {
  n = 0
  for (k in owner_count) norms[n++] = k
  for (i = 0; i < n; i++)
    for (j = i + 1; j < n; j++)
      if (norms[j] < norms[i]) { t = norms[i]; norms[i] = norms[j]; norms[j] = t }

  first = 1
  for (i = 0; i < n; i++) {
    k = norms[i]; c = owner_count[k]
    if (dup_only == "true" && c <= 1) continue

    if (!first) print ","
    first = 0

    printf "  \"%s\": {\n", jesc(first_orig[k])
    printf "    \"duplicate\": %s,\n", (c > 1 ? "true" : "false")
    printf "    \"owners\": [\n"

    nlines = split(owners[k], lines, "\n")
    oi = 0
    for (li = 1; li <= nlines; li++) {
      if (lines[li] == "") continue
      if (oi++ > 0) print ","
      printf "      \"%s\"", jesc(lines[li])
    }
    print "\n    ]\n  }"
  }
  print "\n}"
}
'
}

# ----------------------------
# CLI parsing
# ----------------------------
parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -a|--all)            MODE="all"; shift ;;
      -d|--duplicates)     MODE="duplicates"; shift ;;
      -s|--schema)         FILTER_SCHEMA="${2:-}"; [[ -z "$FILTER_SCHEMA" ]] && die "--schema requires REGEX"; shift 2 ;;
      -k|--accel)          FILTER_ACCEL="${2:-}"; [[ -z "$FILTER_ACCEL" ]] && die "--accel requires REGEX"; shift 2 ;;
      -o|--owner)          FILTER_OWNER="${2:-}"; [[ -z "$FILTER_OWNER" ]] && die "--owner requires REGEX"; shift 2 ;;
      -r|--raw)            FORMAT="raw"; shift ;;
      -j|--json)           FORMAT="json"; shift ;;
      --no-color)          NO_COLOR=true; shift ;;
      -q|--quiet)          QUIET=true; shift ;;
      --list-schemas)      LIST_SCHEMAS=true; shift ;;
      --list-relocatable)  LIST_RELOCATABLE=true; shift ;;
      --list-keys)         LIST_KEYS_SCHEMA="${2:-}"; [[ -z "$LIST_KEYS_SCHEMA" ]] && die "--list-keys requires SCHEMA[:PATH]"; shift 2 ;;
      -h|--help)           usage ;;
      *)                   die "unknown option: $1 (use --help)" ;;
    esac
  done
}

# ----------------------------
# Main
# ----------------------------
main() {
  have gsettings || die "gsettings not found (install glib2)"
  have awk       || die "awk not found"

  parse_args "$@"

  if [[ "$LIST_RELOCATABLE" == true ]]; then
    gsettings list-relocatable-schemas 2>/dev/null | sort -u
    exit 0
  fi

  if [[ -n "$LIST_KEYS_SCHEMA" ]]; then
    gsettings list-keys "$LIST_KEYS_SCHEMA"
    exit 0
  fi

  local candidates
  candidates="$(discover_candidate_schemas)"

  if [[ "$LIST_SCHEMAS" == true ]]; then
    printf "%s\n" "$candidates"
    exit 0
  fi

  TMP="$(mktemp)"
  trap '[[ -n "${TMP:-}" ]] && rm -f -- "$TMP"' EXIT

  log "Discovering schema instances…"

  local -a instances=()
  local schema inst

  while IFS= read -r schema; do
    [[ -z "$schema" ]] && continue
    while IFS= read -r inst; do
      [[ -z "$inst" ]] && continue
      instances+=("$inst")
    done < <(derive_schema_instances "$schema")
  done <<<"$candidates"

  # Deduplicate (guard against empty array)
  if ((${#instances[@]})); then
    mapfile -t instances < <(printf "%s\n" "${instances[@]}" | sort -u)
  fi

  log "Processing ${#instances[@]} schema instance(s)…"

  local x
  for x in "${instances[@]}"; do
    collect_from_schema_instance "$x" >>"$TMP"
  done

  collect_custom_media_keys >>"$TMP"

  if [[ ! -s "$TMP" ]]; then
    if [[ "$FORMAT" == "json" ]]; then
      printf "{\n}\n"
    else
      log "No accelerators found."
    fi
    exit 0
  fi

  local duplicates_only="false"
  [[ "$MODE" == "duplicates" ]] && duplicates_only="true"

  case "$FORMAT" in
    human)
      report_human "$duplicates_only" <"$TMP"
      ;;
    raw)
      report_raw "$duplicates_only" <"$TMP"
      if [[ "$MODE" == "duplicates" ]]; then
        awk -F'\t' '{ c[$1]++ } END { for (k in c) if (c[k] > 1) exit 1 }' "$TMP" || exit 1
      fi
      ;;
    json)
      report_json "$duplicates_only" <"$TMP"
      if [[ "$MODE" == "duplicates" ]]; then
        awk -F'\t' '{ c[$1]++ } END { for (k in c) if (c[k] > 1) exit 1 }' "$TMP" || exit 1
      fi
      ;;
    *)
      die "internal: unknown format: $FORMAT"
      ;;
  esac
}

main "$@"

