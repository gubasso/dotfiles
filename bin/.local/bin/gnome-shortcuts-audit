#!/usr/bin/env bash
#
# gnome-shortcuts-audit - Audit GNOME keybindings for duplicate accelerators (optional rebind mode)
#
# Scans GSettings for keyboard shortcuts across:
#   - Mutter/WM keybindings (org.gnome.desktop.wm.keybindings)
#   - GNOME Shell keybindings (org.gnome.shell.keybindings)
#   - Mutter keybindings (org.gnome.mutter.keybindings, wayland variant)
#   - Media keys + custom shortcuts (org.gnome.settings-daemon.plugins.media-keys)
#   - Extensions (org.gnome.shell.extensions.*)
#   - Any schema matching: keybindings, shortcut, hotkey
#
# This tool is READ-ONLY by default.
# It can modify settings only when using: --set ... --apply
#
# USAGE:
#   gnome-shortcuts-audit [OPTIONS]
#
# OPTIONS:
#   -a, --all                   Show all accelerators (default)
#   -d, --duplicates            Show only duplicates; exit 1 if any found
#   -s, --schema REGEX          Filter owners by schema (case-insensitive regex)
#   -k, --accel REGEX           Filter accelerators (case-insensitive regex; matches original or normalized)
#   -o, --owner REGEX           Filter owner line (schema/key/detail; case-insensitive)
#   -r, --raw                   Raw TSV output: accel<TAB>schema_instance<TAB>key<TAB>detail
#   -j, --json                  JSON output
#       --no-color              Disable ANSI colors (human output)
#   -q, --quiet                 Suppress progress messages
#       --list-schemas          List discovered candidate schemas and exit
#       --list-relocatable      List relocatable schemas and exit
#       --list-keys SCHEMA[:PATH]
#                               List keys for a schema instance and exit
#       --debug-schema-path     Show computed GSETTINGS_SCHEMA_DIR and exit
#       --set SCHEMA[:PATH] KEY ACCEL
#                               Rebind ACCEL: remove from all other owners, then set on target
#       --apply                 Apply changes for --set (otherwise dry-run)
#       --dry-run               Explicitly do not apply (default for --set)
#   -h, --help                  Show this help
#
# EXAMPLES:
#   gnome-shortcuts-audit
#   gnome-shortcuts-audit -d
#   gnome-shortcuts-audit -s paperwm
#   gnome-shortcuts-audit -k '<Super>'
#   gnome-shortcuts-audit -o 'media-keys\.custom'
#   gnome-shortcuts-audit -r
#   gnome-shortcuts-audit -j
#   gnome-shortcuts-audit --list-schemas
#   gnome-shortcuts-audit --list-keys org.gnome.desktop.wm.keybindings
#   gnome-shortcuts-audit --debug-schema-path
#   # Dry-run: show what would be changed
#   gnome-shortcuts-audit --set org.gnome.shell.keybindings toggle-overview '<Super>p'
#   # Apply: actually move the accel everywhere + set target
#   gnome-shortcuts-audit --set org.gnome.shell.keybindings toggle-overview '<Super>p' --apply
#
# EXIT CODES:
#   0 - Success (or no duplicates in -d mode)
#   1 - Duplicates found (only in -d mode)
#   2 - Error / invalid usage
#
# END_HELP

set -euo pipefail
export LC_ALL=C

# ------------------------------------------------------------------------------
# Usage: extracted from header docstring (single source of truth).
# ------------------------------------------------------------------------------
usage() {
  # Print everything from "# USAGE:" up to (but not including) "# END_HELP"
  sed -n '/^# USAGE:$/,/^# END_HELP$/{
    /^# END_HELP$/q
    s/^# \?//
    p
  }' "$0"
  exit 0
}

# ----------------------------
# Defaults / CLI state
# ----------------------------
MODE="all"              # all|duplicates
FORMAT="human"          # human|raw|json
FILTER_SCHEMA=""        # regex, case-insensitive
FILTER_ACCEL=""         # regex, case-insensitive
FILTER_OWNER=""         # regex, case-insensitive (matches "schema key [detail]")
NO_COLOR=false
QUIET=false
TMP=""

# Mutating mode (optional)
SET_MODE=false
SET_TARGET_INST=""
SET_TARGET_KEY=""
SET_ACCEL=""
APPLY=false

LIST_SCHEMAS=false
LIST_RELOCATABLE=false
LIST_KEYS_SCHEMA=""
DEBUG_SCHEMA_PATH=false

# ----------------------------
# Core schema set (high-value)
# ----------------------------
CORE_SCHEMAS=(
  "org.gnome.desktop.wm.keybindings"
  "org.gnome.shell.keybindings"
  "org.gnome.mutter.keybindings"
  "org.gnome.mutter.wayland.keybindings"
  "org.gnome.settings-daemon.plugins.media-keys"
)

DISCOVERY_REGEX='(keybindings|keybinding|shortcut|shortcuts|hotkey|hotkeys)'
EXT_PREFIX="org.gnome.shell.extensions."

# ----------------------------
# Helpers
# ----------------------------
die() { printf "error: %s\n" "$*" >&2; exit 2; }

log() {
  [[ "$QUIET" == true ]] && return 0
  printf "%s\n" "$*" >&2
}

have() { command -v "$1" >/dev/null 2>&1; }

is_tty() { [[ -t 1 ]]; }

use_color() { is_tty && [[ "$NO_COLOR" == false ]]; }

trim() {
  # Pure bash whitespace trim
  local s="$1"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf "%s" "$s"
}

# ----------------------------
# GNOME accelerator heuristics
# ----------------------------
looks_like_accel() {
  local s
  s="$(trim "$1")"
  [[ -z "$s" ]] && return 1
  [[ "$s" == "disabled" || "$s" == "none" || "$s" == "nothing" ]] && return 1
  [[ "$s" == @* || "$s" == /* || "$s" == *" "* ]] && return 1

  # GNOME standard: <Modifier>key
  [[ "$s" == \<*\>* ]] && return 0

  # XF86 media keys
  [[ "$s" =~ ^XF86[[:alnum:]_]+$ ]] && return 0

  # Function keys
  [[ "$s" =~ ^F([1-9]|1[0-9]|2[0-4])$ ]] && return 0

  # Named keys
  case "$s" in
    Print|Pause|Menu|Tab|Escape|Home|End|Page_Up|Page_Down|Insert|Delete|BackSpace|Return|Enter|space|Up|Down|Left|Right)
      return 0 ;;
  esac

  # Single alphanumeric (rare)
  [[ "$s" =~ ^[[:alnum:]]$ ]] && return 0

  # Keysyms with underscore (KP_1, Page_Up, etc.)
  [[ "$s" =~ ^[[:alnum:]_]+$ && "$s" == *_* ]] && return 0

  return 1
}

get_base_schema() {
  # Extract base schema from instance identifier (strips :path suffix for relocatable schemas).
  local inst="$1"
  printf "%s" "${inst%%:*}"
}

build_child_instance() {
  # Construct proper child instance identifier.
  # Args: child_schema parent_inst
  local child_schema="$1"
  local parent_inst="$2"

  # Check if child is relocatable
  if gsettings list-relocatable-schemas 2>/dev/null | grep -Fxq "$child_schema"; then
    # For relocatable child, infer path from parent
    if [[ "$parent_inst" == *:* ]]; then
      local parent_path="${parent_inst#*:}"
      # Child path pattern: parent_path/child_name/
      # Extract child name from schema (last component after last .)
      local child_name="${child_schema##*.}"
      printf "%s:%s%s/" "$child_schema" "$parent_path" "$child_name"
    else
      # Parent is not relocatable, child probably isn't either or has default path
      printf "%s" "$child_schema"
    fi
  else
    # Non-relocatable: use schema ID directly
    printf "%s" "$child_schema"
  fi
}

normalize_accel() {
  # Canonicalize modifier aliases and ordering.
  # For non-<...> accelerators (XF86...), return as-is.
  local a
  a="$(trim "$1")"
  [[ "$a" != *"<"* ]] && { printf "%s" "$a"; return 0; }

  local rest="$a"
  local -a mods=()
  local m

  while [[ "$rest" =~ ^\<([^>]*)\>(.*)$ ]]; do
    m="${BASH_REMATCH[1]}"
    rest="${BASH_REMATCH[2]}"

    case "${m,,}" in
      primary|control|ctrl) m="Ctrl" ;;
      mod1|alt)             m="Alt" ;;
      shift)                m="Shift" ;;
      super|mod4)           m="Super" ;;
      meta)                 m="Meta" ;;
      hyper)                m="Hyper" ;;
      *)                    m="$m" ;;
    esac
    mods+=("$m")
  done

  # Deduplicate
  local -A seen=()
  for m in "${mods[@]}"; do
    seen["$m"]=1
  done

  # Canonical order
  local -a ordered=()
  for m in Ctrl Alt Shift Super Meta Hyper; do
    [[ -n "${seen[$m]:-}" ]] && ordered+=("$m") && unset "seen[$m]"
  done

  # Append remaining (unknown modifiers, sorted)
  local -a unknown=()
  for m in "${!seen[@]}"; do
    unknown+=("$m")
  done
  if ((${#unknown[@]} > 0)); then
    mapfile -t unknown < <(printf "%s\n" "${unknown[@]}" | sort)
    ordered+=("${unknown[@]}")
  fi

  local out=""
  for m in "${ordered[@]}"; do
    out+="<${m}>"
  done
  out+="$rest"

  printf "%s" "$out"
}

extract_quoted_strings() {
  # Extract all single-quoted tokens from a GVariant string.
  local v="$1"
  printf "%s" "$v" | grep -oE "'[^']*'" | sed "s/^'//; s/'$//" || true
}

# ----------------------------
# Extension schema discovery
# ----------------------------
xdg_data_dirs() {
  # Emit XDG data roots, one per line.
  # Defaults per XDG Base Directory spec:
  #   XDG_DATA_HOME: ~/.local/share
  #   XDG_DATA_DIRS: /usr/local/share:/usr/share
  local data_home="${XDG_DATA_HOME:-$HOME/.local/share}"
  local data_dirs="${XDG_DATA_DIRS:-/usr/local/share:/usr/share}"

  printf "%s\n" "$data_home"
  tr ':' '\n' <<<"$data_dirs"
}

discover_extension_schema_dirs() {
  # Finds GNOME Shell extension schema dirs that contain gschemas.compiled.
  #
  # Locations covered (XDG-aware):
  #   - For each base in XDG_DATA_HOME + XDG_DATA_DIRS:
  #       BASE/gnome-shell/extensions/*/schemas/gschemas.compiled
  #   - Flatpak host paths (common on Arch):
  #       ~/.var/app/*/data/gnome-shell/extensions/*/schemas/gschemas.compiled
  #       /var/lib/flatpak/app/*/current/active/files/share/gnome-shell/extensions/*/schemas/gschemas.compiled
  #
  # Output: one directory per line

  local -a dirs=()
  local f base
  local -a bases=()

  (
    shopt -s nullglob

    # XDG roots
    mapfile -t bases < <(xdg_data_dirs | awk 'NF' | sort -u)
    for base in "${bases[@]}"; do
      for f in "$base/gnome-shell/extensions"/*/schemas/gschemas.compiled; do
        dirs+=("$(dirname "$f")")
      done
    done

    # Flatpak user extensions
    for f in "$HOME/.var/app"/*/data/gnome-shell/extensions/*/schemas/gschemas.compiled; do
      dirs+=("$(dirname "$f")")
    done

    # Flatpak system extensions
    for f in /var/lib/flatpak/app/*/current/active/files/share/gnome-shell/extensions/*/schemas/gschemas.compiled; do
      dirs+=("$(dirname "$f")")
    done

    if ((${#dirs[@]})); then
      printf "%s\n" "${dirs[@]}" | sort -u
    fi
  )
}

build_schema_path() {
  # Construct a de-duplicated colon-separated GSETTINGS_SCHEMA_DIR.
  # Includes:
  #   - discovered extension schema dirs (with gschemas.compiled)
  #   - GLib schema dirs under XDG roots (user-compiled schemas)
  #   - Flatpak GLib schema dirs
  #   - existing $GSETTINGS_SCHEMA_DIR entries (if any)
  #   - default GLib schema dirs (if present)
  #
  # Output: path string (may be empty)

  local -a parts=()
  local -a ext_dirs=()
  local -a env_dirs=()
  local -a xdg_bases=()
  local -a out=()
  local -A seen=()
  local p

  mapfile -t ext_dirs < <(discover_extension_schema_dirs || true)
  ((${#ext_dirs[@]})) && parts+=("${ext_dirs[@]}")

  # Add any GLib schema dirs under XDG roots (covers custom prefixes and ~/.local/share/glib-2.0/schemas)
  mapfile -t xdg_bases < <(xdg_data_dirs | awk 'NF' | sort -u)
  for p in "${xdg_bases[@]}"; do
    [[ -d "$p/glib-2.0/schemas" ]] && parts+=("$p/glib-2.0/schemas")
  done

  # Flatpak host-side schema roots (GLib schemas inside Flatpak installations)
  for p in "$HOME/.var/app"/*/data; do
    [[ -d "$p/glib-2.0/schemas" ]] && parts+=("$p/glib-2.0/schemas")
  done
  for p in /var/lib/flatpak/app/*/current/active/files/share; do
    [[ -d "$p/glib-2.0/schemas" ]] && parts+=("$p/glib-2.0/schemas")
  done

  if [[ -n "${GSETTINGS_SCHEMA_DIR:-}" ]]; then
    IFS=: read -r -a env_dirs <<<"${GSETTINGS_SCHEMA_DIR}"
    ((${#env_dirs[@]})) && parts+=("${env_dirs[@]}")
  fi

  # Keep explicit defaults as a belt-and-suspenders fallback
  [[ -d /usr/local/share/glib-2.0/schemas ]] && parts+=("/usr/local/share/glib-2.0/schemas")
  [[ -d /usr/share/glib-2.0/schemas ]]       && parts+=("/usr/share/glib-2.0/schemas")

  for p in "${parts[@]}"; do
    [[ -z "$p" ]] && continue
    [[ -d "$p" ]] || continue
    [[ -f "$p/gschemas.compiled" ]] || continue
    if [[ -z "${seen[$p]:-}" ]]; then
      out+=("$p")
      seen["$p"]=1
    fi
  done

  ((${#out[@]})) || return 0
  local IFS=:
  printf "%s" "${out[*]}"
}

# ----------------------------
# Optional rebind (mutating) helpers
# ----------------------------
gvariant_is_array_of_strings() {
  # gsettings get for string arrays typically returns:
  #   ['<Super>p']
  # or:
  #   @as []
  [[ "$1" == \[* || "$1" == @as* ]]
}

gvariant_is_string() {
  [[ "$1" == \'*\' ]]
}

build_gvariant_array() {
  # Build "['a', 'b']" (GVariant array of strings)
  local -a items=("$@")
  if ((${#items[@]} == 0)); then
    printf "[]"
    return 0
  fi
  local out="["
  local i
  for i in "${!items[@]}"; do
    out+="'${items[$i]}'"
    if (( i < ${#items[@]} - 1 )); then
      out+=", "
    fi
  done
  out+="]"
  printf "%s" "$out"
}

remove_accel_from_setting() {
  # Remove any entry whose normalized accel matches target_norm.
  local inst="$1"
  local key="$2"
  local target_norm="$3"

  local cur
  cur="$(gsettings get "$inst" "$key" 2>/dev/null)" || return 0

  if gvariant_is_array_of_strings "$cur"; then
    local -a els=()
    local e
    while IFS= read -r e; do
      [[ -z "$e" ]] && continue
      if [[ "$(normalize_accel "$e")" == "$target_norm" ]]; then
        continue
      fi
      els+=("$e")
    done < <(extract_quoted_strings "$cur")

    local newv
    newv="$(build_gvariant_array "${els[@]}")"
    gsettings set "$inst" "$key" "$newv" >/dev/null
    return 0
  fi

  if gvariant_is_string "$cur"; then
    local inner="${cur#\'}"; inner="${inner%\'}"
    if [[ "$(normalize_accel "$inner")" == "$target_norm" ]]; then
      gsettings set "$inst" "$key" "''" >/dev/null
    fi
    return 0
  fi

  return 0
}

set_accel_on_setting() {
  local inst="$1"
  local key="$2"
  local accel="$3"

  local cur
  cur="$(gsettings get "$inst" "$key" 2>/dev/null)" || die "cannot read target: $inst $key"

  if gvariant_is_array_of_strings "$cur"; then
    gsettings set "$inst" "$key" "['$accel']" >/dev/null
    return 0
  fi

  if gvariant_is_string "$cur"; then
    gsettings set "$inst" "$key" "'$accel'" >/dev/null
    return 0
  fi

  die "unsupported target value type for: $inst $key (got: $cur)"
}

run_set_mode() {
  local tmpfile="$1"

  [[ -n "$SET_TARGET_INST" && -n "$SET_TARGET_KEY" && -n "$SET_ACCEL" ]] || die "--set requires SCHEMA[:PATH] KEY ACCEL"
  looks_like_accel "$SET_ACCEL" || die "invalid accelerator for --set: $SET_ACCEL"

  local target_norm
  target_norm="$(normalize_accel "$SET_ACCEL")"

  local -a to_clear=()
  mapfile -t to_clear < <(
    awk -F'\t' -v n="$target_norm" -v ti="$SET_TARGET_INST" -v tk="$SET_TARGET_KEY" '
      $1 == n {
        if (!($3 == ti && $4 == tk)) print $3 "\t" $4
      }
    ' "$tmpfile" | sort -u
  )

  printf "Rebind plan\n"
  printf "  accel:      %s\n" "$SET_ACCEL"
  printf "  normalized: %s\n" "$target_norm"
  printf "  target:     %s %s\n" "$SET_TARGET_INST" "$SET_TARGET_KEY"
  printf "\n"

  if ((${#to_clear[@]} == 0)); then
    printf "Nothing to clear elsewhere (no other owners found for this accelerator).\n"
  else
    printf "Will clear from:\n"
    local line inst key
    for line in "${to_clear[@]}"; do
      inst="${line%%$'\t'*}"
      key="${line#*$'\t'}"
      printf "  - %s %s\n" "$inst" "$key"
    done
  fi

  printf "\nWill set target to:\n"
  printf "  - %s %s = %s\n" "$SET_TARGET_INST" "$SET_TARGET_KEY" "$SET_ACCEL"
  printf "\n"

  if [[ "$APPLY" != true ]]; then
    printf "Dry-run: no changes applied. Re-run with --apply to execute.\n"
    return 0
  fi

  log "Applying rebind…"

  local line inst key
  for line in "${to_clear[@]}"; do
    inst="${line%%$'\t'*}"
    key="${line#*$'\t'}"
    remove_accel_from_setting "$inst" "$key" "$target_norm"
  done

  # Clear from target first (handles duplicates-in-place), then set
  remove_accel_from_setting "$SET_TARGET_INST" "$SET_TARGET_KEY" "$target_norm"
  set_accel_on_setting "$SET_TARGET_INST" "$SET_TARGET_KEY" "$SET_ACCEL"

  log "Rebind applied."
  return 0
}

# ----------------------------
# Schema discovery
# ----------------------------
list_all_schemas() {
  {
    gsettings list-schemas 2>/dev/null || true
    gsettings list-relocatable-schemas 2>/dev/null || true
  } | sort -u
}

discover_candidate_schemas() {
  local all
  all="$(list_all_schemas)"
  local -a out=()
  local s

  for s in "${CORE_SCHEMAS[@]}"; do
    grep -Fxq "$s" <<<"$all" && out+=("$s")
  done

  while IFS= read -r s; do
    [[ -n "$s" ]] && out+=("$s")
  done < <(grep -E "^${EXT_PREFIX}" <<<"$all" || true)

  while IFS= read -r s; do
    [[ -n "$s" ]] && out+=("$s")
  done < <(grep -Ei "$DISCOVERY_REGEX" <<<"$all" || true)

  printf "%s\n" "${out[@]}" | sort -u
}

derive_schema_instances() {
  # Emit schema instances:
  # - Non-relocatable: SCHEMA
  # - Relocatable: we attempt a best-effort extension-path heuristic
  local schema="$1"

  if gsettings list-schemas 2>/dev/null | grep -Fxq "$schema"; then
    printf "%s\n" "$schema"
    return 0
  fi

  gsettings list-relocatable-schemas 2>/dev/null | grep -Fxq "$schema" || return 0

  # Extension heuristic: org.gnome.shell.extensions.NAME -> /org/gnome/shell/extensions/name/
  if [[ "$schema" == "${EXT_PREFIX}"* ]]; then
    local name="${schema#"${EXT_PREFIX}"}"
    printf "%s:/org/gnome/shell/extensions/%s/\n" "$schema" "$name"
  fi
}

schema_has_keys() {
  gsettings list-keys "$1" >/dev/null 2>&1
}

# ----------------------------
# Collector
# Each collector prints TSV records to stdout:
#   norm <TAB> orig <TAB> schema_instance <TAB> key <TAB> detail
# ----------------------------
collect_from_schema_instance() {
  local inst="$1"
  schema_has_keys "$inst" || return 0

  local base_schema
  base_schema="$(get_base_schema "$inst")"

  # Track processed keys to avoid duplicates from child schemas
  local -A processed=()

  local schema key value_rest accel norm owner_inst dedup_key
  while IFS=$' \t' read -r schema key value_rest; do
    [[ -z "${schema:-}" || -z "${key:-}" || -z "${value_rest:-}" ]] && continue
    [[ "$value_rest" != *"'"* ]] && continue

    # Determine the correct owner instance based on the actual schema
    if [[ "$schema" == "$base_schema" ]]; then
      # This row belongs to the instance we're scanning
      owner_inst="$inst"
    else
      # This is a child schema row - build proper child instance identifier
      owner_inst="$(build_child_instance "$schema" "$inst")"
    fi

    # Deduplicate: skip if we've already processed this (owner_inst, key) pair
    dedup_key="${owner_inst}${key}"
    [[ -n "${processed[$dedup_key]:-}" ]] && continue
    processed[$dedup_key]=1

    while IFS= read -r accel; do
      [[ -z "$accel" ]] && continue
      looks_like_accel "$accel" || continue
      norm="$(normalize_accel "$accel")"
      printf "%s\t%s\t%s\t%s\t%s\n" "$norm" "$accel" "$owner_inst" "$key" ""
    done < <(extract_quoted_strings "$value_rest")

  done < <(gsettings list-recursively "$inst" 2>/dev/null)
}

collect_custom_media_keys() {
  local base="org.gnome.settings-daemon.plugins.media-keys"
  schema_has_keys "$base" || return 0

  local paths_value
  paths_value="$(gsettings get "$base" custom-keybindings 2>/dev/null || echo "@as []")"
  [[ "$paths_value" == "@as []" || "$paths_value" == "[]" ]] && return 0

  local path inst name binding command accel norm detail
  while IFS= read -r path; do
    [[ -z "$path" ]] && continue

    inst="org.gnome.settings-daemon.plugins.media-keys.custom-keybinding:${path}"
    schema_has_keys "$inst" || continue

    name="$(gsettings get "$inst" name 2>/dev/null || echo "''")"
    binding="$(gsettings get "$inst" binding 2>/dev/null || echo "''")"
    command="$(gsettings get "$inst" command 2>/dev/null || echo "''")"

    name="${name#\'}"; name="${name%\'}"
    command="${command#\'}"; command="${command%\'}"

    while IFS= read -r accel; do
      [[ -z "$accel" ]] && continue
      looks_like_accel "$accel" || continue
      norm="$(normalize_accel "$accel")"
      detail="name=${name}; command=${command}"
      printf "%s\t%s\t%s\t%s\t%s\n" "$norm" "$accel" "$inst" "binding" "$detail"
    done < <(extract_quoted_strings "$binding")

  done < <(printf "%s" "$paths_value" | grep -oE "'/[^']+/'" | tr -d "'" || true)
}

# ----------------------------
# Reporting
# ----------------------------
report_human() {
  local duplicates_only="$1"
  local uc=0
  use_color && uc=1

  awk -v dup_only="$duplicates_only" \
      -v schema_re="$FILTER_SCHEMA" \
      -v accel_re="$FILTER_ACCEL" \
      -v owner_re="$FILTER_OWNER" \
      -v use_color="$uc" \
      -v mode="$MODE" \
'
function ci_match(s, re) { return re == "" || tolower(s) ~ tolower(re) }
function esc(s) { gsub(/\t/, "    ", s); return s }
BEGIN { FS=OFS="\t" }
{
  norm=$1; orig=$2; schema=$3; key=$4; detail=$5
  if (!ci_match(schema, schema_re)) next
  if (!ci_match(orig, accel_re) && !ci_match(norm, accel_re)) next

  owner_line = schema " " key
  if (detail != "") owner_line = owner_line " [" detail "]"
  if (!ci_match(owner_line, owner_re)) next

  id = norm SUBSEP schema SUBSEP key SUBSEP detail
  if (id in seen) next
  seen[id] = 1
  owners[norm] = owners[norm] "\n" owner_line
  owner_count[norm]++
  if (!(norm in first_orig)) first_orig[norm] = orig
}
END {
  n = 0
  for (k in owner_count) norms[n++] = k
  for (i = 0; i < n; i++)
    for (j = i + 1; j < n; j++)
      if (norms[j] < norms[i]) { t = norms[i]; norms[i] = norms[j]; norms[j] = t }

  dup_found = 0
  for (i = 0; i < n; i++) {
    k = norms[i]; c = owner_count[k]
    if (dup_only == "true" && c <= 1) continue
    if (c > 1) dup_found = 1

    a = first_orig[k]
    if (use_color) {
      if (c > 1) printf "\033[1;31m%s\033[0m \033[1;33m[DUPLICATE: %d owners]\033[0m\n", a, c
      else        printf "\033[1;32m%s\033[0m\n", a
    } else {
      if (c > 1) printf "%s [DUPLICATE: %d owners]\n", a, c
      else       printf "%s\n", a
    }

    nlines = split(owners[k], lines, "\n")
    for (li = 1; li <= nlines; li++)
      if (lines[li] != "") printf "  - %s\n", esc(lines[li])
    print ""
  }

  exit (mode == "duplicates" && dup_found ? 1 : 0)
}
'
}

report_raw() {
  local duplicates_only="$1"

  awk -v dup_only="$duplicates_only" \
      -v schema_re="$FILTER_SCHEMA" \
      -v accel_re="$FILTER_ACCEL" \
      -v owner_re="$FILTER_OWNER" \
'
function ci_match(s, re) { return re == "" || tolower(s) ~ tolower(re) }
BEGIN { FS=OFS="\t" }
{
  norm=$1; orig=$2; schema=$3; key=$4; detail=$5
  if (!ci_match(schema, schema_re)) next
  if (!ci_match(orig, accel_re) && !ci_match(norm, accel_re)) next

  owner_line = schema " " key
  if (detail != "") owner_line = owner_line " [" detail "]"
  if (!ci_match(owner_line, owner_re)) next

  id = norm SUBSEP schema SUBSEP key SUBSEP detail
  if (id in seen) next
  seen[id] = 1
  rec[++nrec] = $0
  cnt[norm]++
}
END {
  for (i = 1; i <= nrec; i++) {
    split(rec[i], f, "\t")
    if (dup_only == "true" && cnt[f[1]] <= 1) continue
    print f[2], f[3], f[4], f[5]
  }
}
'
}

report_json() {
  local duplicates_only="$1"

  awk -v dup_only="$duplicates_only" \
      -v schema_re="$FILTER_SCHEMA" \
      -v accel_re="$FILTER_ACCEL" \
      -v owner_re="$FILTER_OWNER" \
'
function ci_match(s, re) { return re == "" || tolower(s) ~ tolower(re) }
function jesc(s) { gsub(/\\/,"\\\\",s); gsub(/"/,"\\\"",s); gsub(/\t/,"\\t",s); gsub(/\r/,"\\r",s); gsub(/\n/,"\\n",s); return s }
BEGIN { FS=OFS="\t"; print "{" }
{
  norm=$1; orig=$2; schema=$3; key=$4; detail=$5
  if (!ci_match(schema, schema_re)) next
  if (!ci_match(orig, accel_re) && !ci_match(norm, accel_re)) next

  owner_line = schema " " key
  if (detail != "") owner_line = owner_line " [" detail "]"
  if (!ci_match(owner_line, owner_re)) next

  id = norm SUBSEP schema SUBSEP key SUBSEP detail
  if (id in seen) next
  seen[id] = 1
  owners[norm] = owners[norm] "\n" owner_line
  owner_count[norm]++
  if (!(norm in first_orig)) first_orig[norm] = orig
}
END {
  n = 0
  for (k in owner_count) norms[n++] = k
  for (i = 0; i < n; i++)
    for (j = i + 1; j < n; j++)
      if (norms[j] < norms[i]) { t = norms[i]; norms[i] = norms[j]; norms[j] = t }

  first = 1
  for (i = 0; i < n; i++) {
    k = norms[i]; c = owner_count[k]
    if (dup_only == "true" && c <= 1) continue

    if (!first) print ","
    first = 0

    printf "  \"%s\": {\n", jesc(first_orig[k])
    printf "    \"duplicate\": %s,\n", (c > 1 ? "true" : "false")
    printf "    \"owners\": [\n"

    nlines = split(owners[k], lines, "\n")
    oi = 0
    for (li = 1; li <= nlines; li++) {
      if (lines[li] == "") continue
      if (oi++ > 0) print ","
      printf "      \"%s\"", jesc(lines[li])
    }
    print "\n    ]\n  }"
  }
  print "\n}"
}
'
}

# ----------------------------
# CLI parsing
# ----------------------------
parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -a|--all)            MODE="all"; shift ;;
      -d|--duplicates)     MODE="duplicates"; shift ;;
      -s|--schema)         FILTER_SCHEMA="${2:-}"; [[ -z "$FILTER_SCHEMA" ]] && die "--schema requires REGEX"; shift 2 ;;
      -k|--accel)          FILTER_ACCEL="${2:-}"; [[ -z "$FILTER_ACCEL" ]] && die "--accel requires REGEX"; shift 2 ;;
      -o|--owner)          FILTER_OWNER="${2:-}"; [[ -z "$FILTER_OWNER" ]] && die "--owner requires REGEX"; shift 2 ;;
      -r|--raw)            FORMAT="raw"; shift ;;
      -j|--json)           FORMAT="json"; shift ;;
      --no-color)          NO_COLOR=true; shift ;;
      -q|--quiet)          QUIET=true; shift ;;
      --list-schemas)      LIST_SCHEMAS=true; shift ;;
      --list-relocatable)  LIST_RELOCATABLE=true; shift ;;
      --list-keys)         LIST_KEYS_SCHEMA="${2:-}"; [[ -z "$LIST_KEYS_SCHEMA" ]] && die "--list-keys requires SCHEMA[:PATH]"; shift 2 ;;
      --debug-schema-path) DEBUG_SCHEMA_PATH=true; shift ;;
      --set)
        SET_MODE=true
        SET_TARGET_INST="${2:-}"
        SET_TARGET_KEY="${3:-}"
        SET_ACCEL="${4:-}"
        [[ -z "$SET_TARGET_INST" || -z "$SET_TARGET_KEY" || -z "$SET_ACCEL" ]] && die "--set requires SCHEMA[:PATH] KEY ACCEL"
        shift 4
        ;;
      --apply)             APPLY=true; shift ;;
      --dry-run)           APPLY=false; shift ;;
      -h|--help)           usage ;;
      *)                   die "unknown option: $1 (use --help)" ;;
    esac
  done
}

# ----------------------------
# Main
# ----------------------------
main() {
  have gsettings || die "gsettings not found (install glib2)"
  have awk       || die "awk not found"

  parse_args "$@"

  # Ensure extension schemas compiled inside GNOME Shell extensions are visible
  # to gsettings list-schemas / list-recursively.
  local schema_path=""
  schema_path="$(build_schema_path || true)"
  if [[ -n "$schema_path" ]]; then
    export GSETTINGS_SCHEMA_DIR="$schema_path"
    log "Using GSETTINGS_SCHEMA_DIR with extension schemas enabled."
  fi

  if [[ "$DEBUG_SCHEMA_PATH" == true ]]; then
    printf "Computed GSETTINGS_SCHEMA_DIR:\n%s\n" "${schema_path//:/$'\n'}" >&2
    exit 0
  fi

  if [[ "$LIST_RELOCATABLE" == true ]]; then
    gsettings list-relocatable-schemas 2>/dev/null | sort -u
    exit 0
  fi

  if [[ -n "$LIST_KEYS_SCHEMA" ]]; then
    gsettings list-keys "$LIST_KEYS_SCHEMA"
    exit 0
  fi

  local candidates
  candidates="$(discover_candidate_schemas)"

  if [[ "$LIST_SCHEMAS" == true ]]; then
    printf "%s\n" "$candidates"
    exit 0
  fi

  TMP="$(mktemp)"
  trap '[[ -n "${TMP:-}" ]] && rm -f -- "$TMP"' EXIT

  log "Discovering schema instances…"

  local -a instances=()
  local schema inst

  while IFS= read -r schema; do
    [[ -z "$schema" ]] && continue
    while IFS= read -r inst; do
      [[ -z "$inst" ]] && continue
      instances+=("$inst")
    done < <(derive_schema_instances "$schema")
  done <<<"$candidates"

  # Deduplicate (guard against empty array)
  if ((${#instances[@]})); then
    mapfile -t instances < <(printf "%s\n" "${instances[@]}" | sort -u)
  fi

  log "Processing ${#instances[@]} schema instance(s)…"

  local x
  for x in "${instances[@]}"; do
    collect_from_schema_instance "$x" >>"$TMP"
  done

  collect_custom_media_keys >>"$TMP"

  if [[ ! -s "$TMP" ]]; then
    if [[ "$FORMAT" == "json" ]]; then
      printf "{\n}\n"
    else
      log "No accelerators found."
    fi
    exit 0
  fi

  # Mutating path: rebind accel to target and exit
  if [[ "$SET_MODE" == true ]]; then
    run_set_mode "$TMP"
    exit $?
  fi

  local duplicates_only="false"
  [[ "$MODE" == "duplicates" ]] && duplicates_only="true"

  case "$FORMAT" in
    human)
      report_human "$duplicates_only" <"$TMP"
      ;;
    raw)
      report_raw "$duplicates_only" <"$TMP"
      if [[ "$MODE" == "duplicates" ]]; then
        awk -F'\t' '{ c[$1]++ } END { for (k in c) if (c[k] > 1) exit 1 }' "$TMP" || exit 1
      fi
      ;;
    json)
      report_json "$duplicates_only" <"$TMP"
      if [[ "$MODE" == "duplicates" ]]; then
        awk -F'\t' '{ c[$1]++ } END { for (k in c) if (c[k] > 1) exit 1 }' "$TMP" || exit 1
      fi
      ;;
    *)
      die "internal: unknown format: $FORMAT"
      ;;
  esac
}

main "$@"
