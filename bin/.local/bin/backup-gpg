#!/usr/bin/env bash
set -euo pipefail

required_cmds=(rg gocryptfs)
missing=()

for cmd in "${required_cmds[@]}"; do
  if ! command -v "$cmd" &>/dev/null; then
    missing+=("$cmd")
  fi
done

if (( ${#missing[@]} > 0 )); then
  echo "âŒ ERROR: the following required commands are missing: ${missing[*]}. Please install them."
  exit 1
fi

usage() {
  cat <<EOF
Usage: $0 "<gpg_id>" "<output_path>"

  <gpg_id>      : GPG identifier (e.g. email, name, or full fingerprint)
  <output_path> : Directory that must be a mounted gocryptfs vault

Example:
  ./backup-gpg.sh "alice@example.com" "/home/alice/secure_vault"
EOF
  exit 1
}

if [[ $# -ne 2 ]]; then
  echo "âŒ Invalid number of arguments."
  usage
fi

gpg_id="$1"
output_path="$2"

if [[ ! -d "$output_path" ]]; then
  echo "âŒ ERROR: Output path '$output_path' does not exist or is not a directory."
  exit 2
fi

# Use findmnt to get the filesystem type; tolerate either "fuse.gocryptfs" or "gocryptfs"
fstype="$(findmnt -n -o FSTYPE --target "$output_path" 2>/dev/null || echo "")"

if [[ -z "$fstype" ]]; then
  echo "âŒ ERROR: '$output_path' is not mounted (findmnt returned nothing)."
  exit 3
elif ! rg -q "gocryptfs" <<< "$fstype"; then
  echo "âŒ ERROR: '$output_path' is mounted as '$fstype', not a gocryptfs vault."
  exit 4
fi

if ! gpg --list-keys "$gpg_id" &>/dev/null; then
  echo "âŒ ERROR: No public key found for '$gpg_id'."
  echo "    Make sure you have imported the key or spelled the identifier correctly."
  exit 5
fi

echo "âœ… Using GPG ID     : $gpg_id"
echo "âœ… Output directory : $output_path"
echo "âœ… Filesystem type  : $fstype"
echo

# a. Export public key
pubfile="$output_path/${gpg_id}.pub.asc"
echo "â€¢ Exporting public key to $pubfile ..."
gpg --armor --export "$gpg_id" > "$pubfile"
echo "  â†’ Done."

# b. Export secret (primary) key
privfile="$output_path/${gpg_id}.priv.asc"
echo "â€¢ Exporting secret key to $privfile ..."
gpg --armor --export-secret-keys "$gpg_id" > "$privfile"
echo "  â†’ Done."

# Secure the secret key file
chmod 600 "$privfile"
echo "  â†’ Set permissions 600 on $privfile"

# c. Export secret subkeys only
subprivfile="$output_path/${gpg_id}.sub_priv.asc"
echo "â€¢ Exporting secret subkeys to $subprivfile ..."
gpg --armor --export-secret-subkeys "$gpg_id" > "$subprivfile"
echo "  â†’ Done."

# Secure the subkey file
chmod 600 "$subprivfile"
echo "  â†’ Set permissions 600 on $subprivfile"

# d. Generate Revocation certificate
revokefile="$output_path/${gpg_id}.revoke.asc"
echo "â€¢ Generating revocation certificate to $revokefile ..."
gpg --output "$revokefile" --gen-revoke "$gpg_id"
echo "  â†’ Done."

# e. Export ownertrust
trustfile="$output_path/ownertrust.txt"
echo "â€¢ Exporting ownertrust database to $trustfile ..."
gpg --export-ownertrust > "$trustfile"
echo "  â†’ Done."

echo
echo "ğŸ” Verifying exported files with 'gpg --list-packets' ..."

echo "  â€¢ Checking public key file..."
gpg --list-packets "$pubfile" >/dev/null

echo "  â€¢ Checking secret key file..."
gpg --list-packets "$privfile" >/dev/null

echo "  â€¢ Checking secret subkeys file..."
gpg --list-packets "$subprivfile" >/dev/null

echo
echo "ğŸ‰ All exports seem structurally valid."

cat <<EOF

Backup completed successfully. Files in '$output_path':

  â€¢ Public key         : $(basename "$pubfile")
  â€¢ Secret key         : $(basename "$privfile")    (mode 600)
  â€¢ Secret subkeys     : $(basename "$subprivfile") (mode 600)
  â€¢ Revocation cert    : $(basename "$revokefile")
  â€¢ Ownertrust         : $(basename "$trustfile")

âš ï¸  REMINDER: Keep the PRIVATE files (secret key, subkeys, revoke certificate, and ownertrust)
    in encrypted or highly secure storage. Do NOT leave them world-readable.

EOF

exit 0
