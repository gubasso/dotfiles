#!/usr/bin/env bash
set -euo pipefail

# ==============================================================================
# dev-sandbox-oneshot
#
# Purpose
# - Provide a one-shot, single-session entry into an existing systemd-nspawn machine ("dev-sandbox") with:
#   - A persistent rootfs under /var/lib/machines/dev-sandbox (must already exist)
#   - Optional per-invocation project bind mount to /workspace/<project-name>
#   - Optional read-only dotfiles mounts from the host into /opt/host-dotfiles* (best-effort)
#   - A fish shell as either root (default shell mode) or a specified container user
#   - A minimal, direct systemd-nspawn invocation path (no provisioning, no machine lifecycle management)
#
# Use cases / problems this solves
# - Creates and manages an isolated environment to run coding AI agents/helpers (e.g., gemini-cli, codex,
#   claude code) without granting them broad access to your host OS.
# - Provides a lightweight â€œenter the sandbox nowâ€ wrapper around systemd-nspawn for ad-hoc work.
# - Enables quick project-context attaches without maintaining separate container instances per repo.
# - Avoids host pollution by running dev tools inside the container filesystem, not on the host.
# - Supports a simple â€œshell vs projectâ€ contract for predictable interactive sessions.
# - Offers an easy path to mount host dotfiles read-only for consistent tooling behavior inside the container.
#
# Assumptions
# - Container rootfs already exists at /var/lib/machines/dev-sandbox (this script does not provision).
# - Host has systemd-nspawn available and sudo privileges to run it.
# - Container has /usr/bin/fish installed.
# - (Optional) Host dotfiles directories exist at:
#   - ~/.dotfiles
#   - ~/.dotfiles-private
# - Host terminal may be kitty; tab-title setting is best-effort and safe to ignore if unsupported.
#
# Notes
# - This script intentionally does not start/stop the machine, detect machine state, or run systemd-run:
#   it directly executes systemd-nspawn against an existing rootfs.
# - This script is designed for a single interactive session per invocation; it does not provide
#   multi-terminal attach semantics to an already-running shared machine (contrast with dev-sandbox).
# - Project mapping is basename -> /workspace/<basename> and is a plain nspawn bind mount for the session.
# - Dotfiles mounts are read-only and only applied if the host directories exist.
# - SYSTEMD_TTY_ENV is set to prevent systemd from adjusting terminal colors/title/emoji (kittty-friendly).
#
# Design overview (high-level)
# - Argument parsing:
#   - Default: project mode (PROJECT_PATH or $PWD) -> bind into /workspace/<basename>, run fish as user "dev"
#   - -S/--shell [USER]: shell mode with no project mount; USER defaults to root if omitted
#   - -D/--shell-dev: convenience for --shell dev
# - Session setup:
#   - Validate rootfs exists early and fail fast if missing
#   - Collect optional dotfiles mounts (read-only) if present
#   - Construct systemd-nspawn command line for the selected mode and exec it
# - Execution:
#   - Single exec of systemd-nspawn; process lifetime matches the interactive terminal session
# ==============================================================================

MACHINE="dev-sandbox"
ROOT="/var/lib/machines/${MACHINE}"

# Host dotfiles (read-only mounts into container)
DOTFILES_PUBLIC="${HOME}/.dotfiles"
DOTFILES_PRIVATE="${HOME}/.dotfiles-private"

# Container mount points
C_DOTFILES_PUBLIC="/opt/host-dotfiles"
C_DOTFILES_PRIVATE="/opt/host-dotfiles-private"

# Disable systemd terminal tint/title/emoji adjustments (keep host kitty colors intact)
SYSTEMD_TTY_ENV=(
  "SYSTEMD_TINT_BACKGROUND=0"
  "SYSTEMD_ADJUST_TERMINAL_TITLE=0"
  "SYSTEMD_EMOJI=0"
)

usage() {
  cat >&2 <<EOF
Usage: $(basename "$0") [OPTIONS] [PROJECT_PATH]

Default (no options):
  Project mode: bind-mount PROJECT_PATH (or \$PWD) into /workspace/<project-name> and start a fish shell
  as user 'dev' in that directory. Also bind-mount dotfiles read-only.

Shell mode:
  -S, --shell [USER]      Start a shell in the container (no project mount).
                          If USER is omitted, defaults to root.
  -D, --shell-dev         Shortcut for --shell dev
  -h, --help              Show this help message

Examples:
  $(basename "$0")                     # project mode: mount \$PWD, start dev shell
  $(basename "$0") /path/to/project    # project mode: mount project, start dev shell
  $(basename "$0") -S                  # shell mode: root shell, no project mount
  $(basename "$0") -S dev              # shell mode: dev shell, no project mount
  $(basename "$0") -D                  # shell mode: dev shell, no project mount
EOF
  exit 1
}

set_kitty_tab_title() {
  local title="$1"
  # Only do anything if we are inside kitty
  if [[ -n "${KITTY_WINDOW_ID:-}" ]]; then
    # Use kitty remote control to set the tab title (best-effort)
    command kitten @ set-tab-title "$title" 2>/dev/null || true
  fi
}

# Check rootfs existence early
if ! sudo test -d "$ROOT"; then
  echo "Error: container rootfs not found at $ROOT" >&2
  exit 1
fi

# Parse arguments
SHELL_MODE=0
SHELL_USER=""
PROJECT_PATH=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -S|--shell)
      SHELL_MODE=1
      shift
      # Optional USER argument: if next token exists and is not another option, treat as USER.
      if [[ $# -gt 0 && "${1:-}" != -* ]]; then
        SHELL_USER="$1"
        shift
      else
        SHELL_USER="root"
      fi
      ;;
    -D|--shell-dev)
      SHELL_MODE=1
      SHELL_USER="dev"
      shift
      ;;
    -h|--help)
      usage
      ;;
    -*)
      echo "Error: unknown option: $1" >&2
      usage
      ;;
    *)
      if [[ -n "$PROJECT_PATH" ]]; then
        echo "Error: multiple project paths provided" >&2
        exit 1
      fi
      PROJECT_PATH="$1"
      shift
      ;;
  esac
done

# Common dotfiles mounts (read-only, only if present)
DOTFILES_MOUNTS=()
if [[ -d "$DOTFILES_PUBLIC" ]]; then
  DOTFILES_MOUNTS+=( "--bind-ro=${DOTFILES_PUBLIC}:${C_DOTFILES_PUBLIC}" )
fi
if [[ -d "$DOTFILES_PRIVATE" ]]; then
  DOTFILES_MOUNTS+=( "--bind-ro=${DOTFILES_PRIVATE}:${C_DOTFILES_PRIVATE}" )
fi

# Build mode-specific systemd-nspawn args and final command
NSPAWN_USER_ARGS=()
MODE_ARGS=()
FISH_ARGS=()

if [[ "$SHELL_MODE" -eq 1 ]]; then
  # ==============================================================================
  # MODE 1/2: SHELL MODE (NO PROJECT MOUNT)
  # ==============================================================================
  if [[ -n "$PROJECT_PATH" ]]; then
    echo "Error: cannot specify PROJECT_PATH with --shell options" >&2
    exit 1
  fi

  # Root is the default for systemd-nspawn; omitting --user is effectively "root".
  if [[ -n "${SHELL_USER:-}" && "$SHELL_USER" != "root" ]]; then
    NSPAWN_USER_ARGS=( "--user=$SHELL_USER" )
  fi

  FISH_ARGS=( /usr/bin/fish )
else
  # ==============================================================================
  # MODE 2/2: PROJECT MODE (DEFAULT)
  # ==============================================================================
  if [[ -z "$PROJECT_PATH" ]]; then
    PROJECT_PATH="$PWD"
  fi

  PROJECT_PATH="$(readlink -f "$PROJECT_PATH")"
  PROJECT_NAME="$(basename "$PROJECT_PATH")"

  if [[ ! -d "$PROJECT_PATH" ]]; then
    echo "Error: project directory '$PROJECT_PATH' does not exist." >&2
    exit 1
  fi

  NSPAWN_USER_ARGS=( "--user=dev" )
  MODE_ARGS+=( "--bind=${PROJECT_PATH}:/workspace/${PROJECT_NAME}" )

  FISH_ARGS=(
    /usr/bin/fish -lc
    "mkdir -p /workspace/${PROJECT_NAME} && cd /workspace/${PROJECT_NAME} && exec fish"
  )
fi

# Set kitty tab title before entering the container (best-effort)
set_kitty_tab_title "ðŸ§Š $MACHINE"

# Single final exec for all modes
CMD=(
  sudo env "${SYSTEMD_TTY_ENV[@]}" systemd-nspawn
  -M "$MACHINE"
  -D "$ROOT"
  "${DOTFILES_MOUNTS[@]}"
  "${NSPAWN_USER_ARGS[@]}"
  "${MODE_ARGS[@]}"
  -E "DEV_SANDBOX=${MACHINE}"
)

exec "${CMD[@]}" "${FISH_ARGS[@]}"
